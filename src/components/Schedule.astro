---
import type { CalendarEvent } from "../lib/calendar";
import type { UlaxGameSerialized } from "../lib/ulax";
import { parseLocalDate } from "../lib/date";

function getMapsUrl(location: string): string {
  return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(location)}`;
}

function truncateLocation(location: string): string {
  const commaIndex = location.indexOf(",");
  return commaIndex > 0 ? location.slice(0, commaIndex) : location;
}

function getEventDate(event: CalendarEvent): string {
  if (event.allDay) return event.start.slice(0, 10);
  // For timed events, extract the date in Pacific time
  const d = new Date(event.start);
  const parts = d.toLocaleDateString("en-CA", { timeZone: "America/Los_Angeles" }); // YYYY-MM-DD
  return parts;
}

function getEventTime(event: CalendarEvent): string {
  if (event.allDay) return "All day";
  const d = new Date(event.start);
  return d.toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    timeZone: "America/Los_Angeles",
  });
}

function isUlaxEvent(event: CalendarEvent): boolean {
  return /u\s?lax/i.test(event.summary);
}

function getEventLabel(event: CalendarEvent): string {
  const s = event.summary.toLowerCase();
  if (s.includes("practice")) return "practice";
  if (s.includes("beers")) return "beers";
  return "event";
}

function getEventLabelColor(label: string): string {
  if (label === "practice") return "text-powder";
  if (label === "beers") return "text-gold";
  return "text-muted";
}

interface Props {
  calendarEvents?: CalendarEvent[];
  ulaxGames?: UlaxGameSerialized[];
  limit?: number;
  barbaryCoastOnly?: boolean;
  upcomingOnly?: boolean;
}

const {
  calendarEvents = [],
  ulaxGames = [],
  limit,
  barbaryCoastOnly = false,
  upcomingOnly = false,
} = Astro.props;

let filteredUlaxGames: UlaxGameSerialized[] = barbaryCoastOnly
  ? ulaxGames.filter((g: UlaxGameSerialized) => g.isBarbaryCoast)
  : ulaxGames;

if (upcomingOnly) {
  filteredUlaxGames = filteredUlaxGames.filter((g) => g.homeScore === null && g.awayScore === null);
}

const nonUlaxEvents: CalendarEvent[] = calendarEvents.filter((e: CalendarEvent) => !isUlaxEvent(e));
const filteredEvents: CalendarEvent[] = upcomingOnly
  ? nonUlaxEvents.filter((e) => new Date(getEventDate(e)) >= new Date(new Date().toDateString()))
  : nonUlaxEvents;

type ScheduleItem =
  | { kind: "ulax"; data: UlaxGameSerialized }
  | { kind: "event"; data: CalendarEvent };

const allItems: ScheduleItem[] = [
  ...filteredUlaxGames.map((g) => ({ kind: "ulax" as const, data: g })),
  ...filteredEvents.map((e) => ({ kind: "event" as const, data: e })),
].sort((a, b) => {
  const dateA = a.kind === "ulax" ? a.data.date : getEventDate(a.data);
  const dateB = b.kind === "ulax" ? b.data.date : getEventDate(b.data);
  return new Date(dateA).getTime() - new Date(dateB).getTime();
});

const displayItems = limit ? allItems.slice(0, limit) : allItems;

function isPlayoffs(game: UlaxGameSerialized): boolean {
  return game.gameType === "playoff" || game.gameType === "championship";
}

function isTBD(game: UlaxGameSerialized): boolean {
  return game.awayTeam === "TBD" || game.homeTeam === "TBD";
}

function getOpponent(game: UlaxGameSerialized): string {
  return game.barbaryCoastIsHome ? game.awayTeam : game.homeTeam;
}

function getBarbaryCoastScore(game: UlaxGameSerialized): number | null {
  return game.barbaryCoastIsHome ? game.homeScore : game.awayScore;
}

function getOpponentScore(game: UlaxGameSerialized): number | null {
  return game.barbaryCoastIsHome ? game.awayScore : game.homeScore;
}

function isWin(game: UlaxGameSerialized): boolean | null {
  const bcScore = getBarbaryCoastScore(game);
  const oppScore = getOpponentScore(game);
  if (bcScore === null || oppScore === null) return null;
  return bcScore > oppScore;
}

function isCompactItem(item: ScheduleItem): boolean {
  if (item.kind === "ulax") return false;
  const label = getEventLabel(item.data);
  return label === "practice" || label === "beers";
}

function getItemDateStr(item: ScheduleItem): string {
  return item.kind === "ulax" ? item.data.date : getEventDate(item.data);
}

// Group items by date
interface DateGroup {
  dateStr: string;
  day: string;
  monthShort: string;
  monthLong: string;
  monthKey: string;
  items: ScheduleItem[];
}

const dateGroups: DateGroup[] = [];
for (const item of displayItems) {
  const dateStr = getItemDateStr(item);
  const last = dateGroups[dateGroups.length - 1];
  if (last && last.dateStr === dateStr) {
    last.items.push(item);
  } else {
    const date = parseLocalDate(dateStr);
    dateGroups.push({
      dateStr,
      day: String(date.getDate()).padStart(2, "0"),
      monthShort: date.toLocaleDateString("en-US", { month: "short" }),
      monthLong: date.toLocaleDateString("en-US", { month: "long" }).toUpperCase(),
      monthKey: `${date.getFullYear()}-${date.getMonth()}`,
      items: [item],
    });
  }
}
---

<div class="space-y-4">
  {dateGroups.map((group, gi) => {
    const prevMonthKey = gi > 0 ? dateGroups[gi - 1].monthKey : null;
    const newMonth = group.monthKey !== prevMonthKey;

    return (
      <div>
        {newMonth && (
          <div class:list={["label text-muted tracking-widest mb-3", gi > 0 && "pt-4"]}>
            {group.monthLong}
          </div>
        )}
        <div class="flex gap-4">
          <!-- Date column -->
          <div class="flex-shrink-0 text-center w-12 border-r border-border pr-4">
            <span class="block text-2xl font-semibold font-mono text-foreground tabular-nums leading-tight">{group.day}</span>
            <span class="block text-xs text-muted uppercase tracking-wide">{group.monthShort}</span>
          </div>

          <!-- Events column -->
          <div class="flex-1 min-w-0 space-y-2">
            {group.items.map((item) => {
              if (item.kind === "ulax") {
                const game = item.data;
                const bcScore = getBarbaryCoastScore(game);
                const oppScore = getOpponentScore(game);
                const hasScore = bcScore !== null && oppScore !== null;
                const won = isWin(game);

                return (
                  <article class="card p-4 sm:p-5">
                    <div class="flex items-center gap-2 mb-1">
                      <span class:list={["label", isPlayoffs(game) ? "text-gold" : "text-powder"]}>
                        [{isPlayoffs(game) ? game.typeName.toLowerCase() : "league"}]
                      </span>
                      <span class="text-sm text-muted font-mono">{game.time}</span>
                    </div>
                    <div class="flex items-center gap-3 flex-wrap">
                      <h3 class="font-medium text-foreground">
                        {isTBD(game) ? game.typeName : `vs ${getOpponent(game)}`}
                      </h3>
                      {hasScore && (
                        <span class:list={["px-2 py-0.5 text-xs font-mono font-medium", won ? "bg-win/10 text-win" : "bg-loss/10 text-loss"]}>
                          {won ? "W" : "L"} {bcScore}-{oppScore}
                        </span>
                      )}
                    </div>
                    <a href={getMapsUrl(game.field)} target="_blank" rel="noopener" class="text-sm text-muted hover:text-foreground transition-colors">
                      {truncateLocation(game.field)}
                    </a>
                  </article>
                );
              }

              const event = item.data;
              const label = getEventLabel(event);
              const compact = isCompactItem(item);

              if (compact) {
                return (
                  <div class="flex items-center gap-2 text-sm py-0.5">
                    <span class:list={["label shrink-0", getEventLabelColor(label)]}>
                      [{label}]
                    </span>
                    <span class="text-muted font-mono text-xs shrink-0">{getEventTime(event)}</span>
                    <span class="text-muted shrink-0">&middot;</span>
                    <span class="text-foreground truncate">{event.summary}</span>
                    {event.location && (
                      <span class="text-muted shrink-0 hidden sm:inline">&middot;</span>
                    )}
                    {event.location && (
                      <a href={getMapsUrl(event.location)} target="_blank" rel="noopener" class="text-muted hover:text-foreground transition-colors hidden sm:inline truncate">
                        {truncateLocation(event.location)}
                      </a>
                    )}
                  </div>
                );
              }

              return (
                <article class="card p-4 sm:p-5">
                  <div class="flex items-center gap-2 mb-1">
                    <span class:list={["label", getEventLabelColor(label)]}>
                      [{label}]
                    </span>
                    <span class="text-sm text-muted font-mono">{getEventTime(event)}</span>
                  </div>
                  <h3 class="font-medium text-foreground">
                    {event.summary}
                  </h3>
                  {event.location && (
                    <a href={getMapsUrl(event.location)} target="_blank" rel="noopener" class="text-sm text-muted hover:text-foreground transition-colors">
                      {truncateLocation(event.location)}
                    </a>
                  )}
                </article>
              );
            })}
          </div>
        </div>
      </div>
    );
  })}
</div>
